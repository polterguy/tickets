
/*
 * Upload file endpoint template file.
 * 
 * This file creates an HTTP PUT endpoint that allows you to upload a single file file as multipart/form-data
 * and stores it in a specified folder on the server.
 * 
 * NOTICE! This file should probably be consumed as a Macro, and not as a template, since this
 * will correctly decorate your file with the correct properties.
 */
.description:Upload file endpoint, allowing you to upload a file to the backend, Notice, [old_file] if declared and existing will be deleted.
.arguments
   file:*
   ticket:long
   message:long
.type:file-upload
.accept:multipart/form-data

// Sanity checking invocation.
validators.mandatory:x:@.arguments/*/file
validators.mandatory:x:@.arguments/*/file/*/name
validators.mandatory:x:@.arguments/*/file/*/stream

// Making sure one and exactly one of [ticket] or [message] was supplied.
if
   or
      and
         eq:x:@.arguments/*/ticket
            .
         eq:x:@.arguments/*/message
            .
      and
         not
            eq:x:@.arguments/*/ticket
               .
         not
            eq:x:@.arguments/*/message
               .
   .lambda
      throw:Only provide one of [message] or [ticket], not both
         public:true
         status:400

// Verifying user has access to invoke endpoint.
auth.ticket.verify:root, admin, guest

// Ensuring user doesn't save files not belonging to his own tickets.
auth.ticket.get
data.connect:tickets
   if
      not
         eq:x:@.arguments/*/ticket
            .
      .lambda
         data.read
            table:tickets
            where
               and
                  user.eq:x:@auth.ticket.get
                  id.eq:x:@.arguments/*/ticket
         if
            not
               exists:x:@data.read/*/*
            .lambda
               throw:No such ticket
                  status:404
                  public:true
   else
      data.read
         table:messages
            join
               type:inner
               table:tickets
               on
                  and
                     messages.ticket.eq:tickets.id
         where
            and
               tickets.user.eq:x:@auth.ticket.get
               messages.id.eq:x:@.arguments/*/message
      if
         not
            exists:x:@data.read/*/*
         .lambda
            throw:No such message
               status:404
               public:true

// Figuring out file extension and sanity checking it.
strings.split:x:@.arguments/*/file/*/name
   .:.
switch:x:@strings.split/0/-
   case:jpeg
   case:jpg
   case:png
   case:gif
      // Do nothing, accept file as is.
   default:
      throw:Only image files please
         public:true
         status:401

// Folder where file should be saved.
.folder:/etc/tickets/
if
   not
      eq:x:@.arguments/*/ticket
         .
   .lambda
      set-value:x:@.folder
         strings.concat
            get-value:x:@.folder
            .:/ticket/id-
            get-value:x:@.arguments/*/ticket
            .:/
else
   set-value:x:@.folder
      strings.concat
         get-value:x:@.folder
         .:/message/id-
         get-value:x:@.arguments/*/message
         .:/

// Ensuring folder exists.
if
   not
      io.folder.exists:x:@.folder
   .lambda
      io.folder.create:x:@.folder

// Saving file with the specified filename to our folder.
.full-path
set-value:x:@.full-path
   strings.concat
      get-value:x:@.folder
      get-value:x:@.arguments/*/file/*/name
io.stream.save-file:x:@.full-path
   get-value:x:@.arguments/*/file/*/stream

// Returning success to caller.
return
   result:success
